var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define(["require", "exports", "vscode-languageclient/lib/common/client", "vscode-languageclient/lib/common/typeDefinition", "vscode-languageclient/lib/common/configuration", "vscode-languageclient/lib/common/implementation", "vscode-languageclient/lib/common/colorProvider", "vscode-languageclient/lib/common/workspaceFolders", "vscode-languageclient/lib/common/foldingRange", "vscode-languageclient/lib/common/callHierarchy", "vscode-languageclient/lib/common/semanticTokens", "vscode-languageclient/lib/common/declaration", "vscode-languageclient/lib/common/client"], function (require, exports, client_1, typeDefinition_1, configuration_1, implementation_1, colorProvider_1, workspaceFolders_1, foldingRange_1, callHierarchy_1, semanticTokens_1, declaration_1, client_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonacoLanguageClient = void 0;
    __exportStar(client_2, exports);
    class MonacoLanguageClient extends client_1.BaseLanguageClient {
        constructor({ id, name, clientOptions, connectionProvider }) {
            super(id || name.toLowerCase(), name, clientOptions);
            this.connectionProvider = connectionProvider;
            this.createConnection = this.doCreateConnection.bind(this);
            // bypass LSP <=> VS Code conversion
            const self = this;
            self._p2c = new Proxy(self._p2c, {
                get: (target, prop) => {
                    if (prop === 'asUri') {
                        return target[prop];
                    }
                    return MonacoLanguageClient.bypassConversion;
                }
            });
            self._c2p = new Proxy(self._c2p, {
                get: (target, prop) => {
                    if (prop === 'asUri') {
                        return target[prop];
                    }
                    if (prop === 'asCompletionParams') {
                        return (textDocument, position, context) => {
                            return {
                                textDocument: target.asTextDocumentIdentifier(textDocument),
                                position,
                                context
                            };
                        };
                    }
                    if (prop === 'asWillSaveTextDocumentParams') {
                        return (event) => {
                            return {
                                textDocument: target.asTextDocumentIdentifier(event.document),
                                reason: event.reason
                            };
                        };
                    }
                    if (prop.endsWith('Params')) {
                        return target[prop];
                    }
                    return MonacoLanguageClient.bypassConversion;
                }
            });
        }
        doCreateConnection() {
            const errorHandler = this.handleConnectionError.bind(this);
            const closeHandler = this.handleConnectionClosed.bind(this);
            return this.connectionProvider.get(errorHandler, closeHandler, this.outputChannel);
        }
        createMessageTransports(encoding) {
            throw new Error('Unsupported');
        }
        registerBuiltinFeatures() {
            super.registerBuiltinFeatures();
            this.registerFeature(new configuration_1.ConfigurationFeature(this));
            this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
            this.registerFeature(new implementation_1.ImplementationFeature(this));
            this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
            this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
            foldingRange_1.FoldingRangeFeature['asFoldingRanges'] = MonacoLanguageClient.bypassConversion;
            this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
            this.registerFeature(new declaration_1.DeclarationFeature(this));
            this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
            this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
            const features = this['_features'];
            for (const feature of features) {
                if (feature instanceof colorProvider_1.ColorProviderFeature) {
                    feature['asColor'] = MonacoLanguageClient.bypassConversion;
                    feature['asColorInformations'] = MonacoLanguageClient.bypassConversion;
                    feature['asColorPresentations'] = MonacoLanguageClient.bypassConversion;
                }
            }
        }
        registerProposedFeatures() {
        }
        getLocale() {
            return navigator.language || 'en-US';
        }
    }
    exports.MonacoLanguageClient = MonacoLanguageClient;
    MonacoLanguageClient.bypassConversion = (result) => result || undefined;
});
//# sourceMappingURL=monaco-language-client.js.map